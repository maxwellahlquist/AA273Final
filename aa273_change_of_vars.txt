% MotionGenesis file:  MGTemplateBasic.txt
% Copyright (c) 2009-2021 Motion Genesis LLC.
%--------------------------------------------------------------------
%   Physical objects.
NewtonianFrame  N
RigidBody       A
RigidFrame      B
RigidBody       C
%--------------------------------------------------------------------
%   Mathematical declarations.
Variable    theta', psi'
Variable    wx', wy', wz'
Specified   v', phi''
SetDt( v = 5  *  ConvertUnits( m/s, UnitSystem ))

% SetDt( v = 0)
Constant    w = 2 rad/sec
% SetDt( phi =  sin(w*t))
% SetDt( phi =  w*t   )
% SetDT( phi = 137.5 *  ConvertUnits( deg, UnitSystem ) *sin(w*t) + 90 *  ConvertUnits( deg, UnitSystem )) % best
% SetDT( phi = 137 *  ConvertUnits( deg, UnitSystem ) *sin(w*t) + 90 *  ConvertUnits( deg, UnitSystem )) % bad vs ^


SetDT( phi = 137.7 *  ConvertUnits( deg, UnitSystem ) *sin(w*t) + 90 *  ConvertUnits( deg, UnitSystem ))

% setDt( phi = atan(2 * cos(2*w*t) /cos(w*t)))
% SetDt( phi =  0)

Variable    Tp, Ty
Constant    g = 9.80665 m/s^2    % Earth's gravitational acceleration.
Constant    k_psi, b_psi, k_theta, b_theta
Constant    r = 8 in        % radius of human torso
Constant    L = 2.5 ft      % height of human torso
Constant    lcm = 1.25 ft     % height to torso CoM
%--------------------------------------------------------------------
%   Mass and inertia properties.
C.SetMass( m = 30 kg )
C.SetInertia( Ccm,  ICxx = 0.25*m*r^2 + 1/12*m*L^2,  ICyy = 0.25*m*r^2 + 1/12*m*L^2,  ICzz = 0.5*m*r^2 )
% C.SetInertia( Ccm,  ICxx,  ICyy,  ICzz )
%--------------------------------------------------------------------
%   Rotational kinematics.
A.RotateZ( N, phi )
B.RotateZ( A, theta )
C.RotateY( B, psi )

% Garbage because they still produce singularities in the kinematic constraints
% constant th = 0
% C.Rotate(A, SpaceYZX, psi, theta, th)
% C.Rotate(A, BodyZYX, theta, psi, th)
C.SetAngularAcceleration(N, wx'*cx> + wy'*cy> + wz'*cz>)
% C.SetRotationMatrixY(B, psi)
% C.setAngularVelocityAcceleration(N, wx*cx> + wy*cy> + wz*cz>)

% Variable    psi'', theta''
KinematicZero[1] = Dot( C.GetAngularVelocity(N), Cx> ) - wx
KinematicZero[2] = Dot( C.GetAngularVelocity(N), Cy> ) - wy
KinematicZero[3] = Dot( C.GetAngularVelocity(N), Cz> ) - wz
SolveDt( kinematicZero = 0,  psi', theta' , wz)
wz' = DT(rhs(wz))
stop
% SolveDt( Dt(kinematicZero) := 0,  psi'', theta'' , wz')
%--------------------------------------------------------------------
%   Translational kinematics.
Ao.SetVelocityAcceleration(N, v*ax>)
Acm.Translate(Ao, 0>)
Co.Translate(Ao, 0>)
Ccm.Translate(Ao, lcm*cz>)
%--------------------------------------------------------------------
%   Motion constraints (if any).
%--------------------------------------------------------------------
%   Add relevant contact/distance forces.
C.AddForceGravity( -g*Nz> )            % Add's gravity force to each massive object.
C.AddTorque(A, -Tp*cy> - Ty*cz> ) % I mke actually need 3D to model the human body correctly...
%--------------------------------------------------------------------
%   Rotational dynamic equations (M = DH/Dt + ...).
%   For static analysis, use  B.GetStatics( aboutPoint ).
% SetgeneralizedSpeeds(wx, wy, wz)
% Dynamics = System.getKaneDynamics()
% Solve(Dynamics = 0, wx', wy', wz')
SetgeneralizedSpeeds(wx, wy)
Dynamics = System.getKaneDynamics()
Solve(Dynamics = 0, wx', wy')

Tp = k_psi*psi + b_psi*psi'
Ty = k_theta*theta + b_theta*theta'
% D(Explicit([wx'; wy'], psi, theta, psi', theta'), [theta, psi, wx, wy])
% D(Explicit([wx'; wy'], psi, theta), [theta, psi, wx, wy])

% explicit(wx', wx, wy)
% explicit(wy', wx, wy)

% Dynamics[1] = Dot(  C.GetDynamics(Ao),  Cy>  )
% Dynamics[2] = Dot(  C.GetDynamics(Ao),  Cz>  )
%--------------------------------------------------------------------
%   Solve algebraic equations for list of unknowns.
% Solve( Dynamics = 0,   theta'', psi'' )

x = dot( Ccm.GetPosition(Ao), ax>)
y = dot( Ccm.GetPosition(Ao), ay>)

Variable wh_x' = dot( Ao.GetVelocity(N), nx>)
Variable wh_y' = dot( Ao.GetVelocity(N), ny>)
Input wh_x = 0, wh_y = 0


Input k_psi = 500, k_theta = 30
Input b_psi = 50, b_theta = 5
% Input v := 0, phi:= 0


% Input psi = 80 deg, psi' = 0 deg/sec
% Input theta = 20 deg, theta' = 0 deg/sec
Input psi = 80 deg, wy = 0 rad/sec
Input theta = 20 deg
SolveSetInput(Evaluate(theta', t =0) = 0, wx = -4 rad/sec)



Tp = k_psi*psi + b_psi*psi'
Ty = k_theta*theta + b_theta*theta'
Output t sec, theta rads, psi rad, phi rad, x m, y m, wh_x m, wh_y m
Input tFinal = pi sec, absError = 1e-05, tStep = 0.04
ODE() aa273
% plot aa273.1[7,8]
plot aa273.1[1,5]


Point   AL (A), AR (A)
Constant    width = 24 in
Al.Translate(Ao, 0.5*width*ay>)
Ar.Translate(Ao, -0.5*width*ay>)

% This file is very not ready to be used for plotting


% D(Dot(a_ccm_n>, [cx>; cy>; cz>]), [theta', theta, psi', psi])
% This command is what goes into getting the jacobian of the accelerometer on the center of mass
% I will need to copy and paste this over to pyhon carefully if I want to use it
% I have to get all of my variable right for this all to work

stop
% D([theta''; psi''], [v, phi, theta', theta, psi', psi]) % This is to get part of the state jacobian...

% I need to set up a default phi and v first, do not plan to 
% design the variable names to have parameters for the names l1, l2, l3... so that I can include multiples of a sensor easily